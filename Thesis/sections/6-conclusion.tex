During this project, we have studied the suitability of the \emph{Dynamic Pipeline Approach} (\dpm) for providing a parallelization of Kruskal's algorithm for computing the Minimum Spanning Tree (\mst) and the capabilities of the framework to maintain the \mst\ of dynamic graphs.

The \emph{underlying forest} representation and proposition~\ref{prop:recursive_mst} allowed to propose a possible algorithm called \DPmst. The chosen language, \Go, facilitated a natural implementation of \DPmst, which allowed for a detailed structural analysis and the proposal of several optimizations. One significant improvement was storing multiple roots per filter, which enhanced the utilization of computational resources by minimizing the creation of excessive goroutines, albeit introducing a new design parameter. Crucially, separating message passing from \mst\ maintenance emerged as a pivotal optimization, applicable across all \dpm\ implementations, significantly enhancing parallelization. This optimization not only addressed inefficiencies but also uncovered and resolved a memory management issue inherent in \Go. Furthermore, it enabled the introduction of a new optimization: caching the \mst\ to prevent redundant computations.

With these improvements, we conducted an extensive experimental comparison of the \DPmst\ algorithm against \FKruskal\ and a message-passing implementation of {\tt Prim}'s algorithm. The results clearly demonstrated that \DPmst\ outperforms its competitors in single-core performance and exhibits far superior scalability in parallel environments.

In summary, \DPmst\ proved to be a highly effective algorithm for computing and maintaining an \mst\ with substantial parallelization, surpassing other algorithms in both performance and scalability. This project validates the \dpm's potential for solving complex graph problems and highlights its broader applicability in parallel computing and provides critical optimizations for the framework itself.

There are many open research directions to explore. For instance, our experiments did not determine the point at which the speed-up stalls due to hardware limitations, so it would be interesting to conduct the same experiments on larger machines. An implementation that allows communication between processes, such as MPI, could be beneficial for experiments with more cores.

Despite the existence of several algorithms for maintaining an \mst\ of dynamic graphs, we could not find any open-source implementations, neither sequential nor parallel. Therefore, implementing and comparing these algorithms against \DPmst\ could be valuable. Some existing algorithms only handle partially dynamic graphs (only insertions or deletions). Modifying the \DPmst\ implementation to leverage such partially dynamic graphs could be advantageous. Another research avenue is to study if data structures proposed for fully dynamic graphs can be used efficiently within each filter and how they compare with just Kruskal's algorithm. Additionally, a more detailed analysis of how the number of roots affects performance would be interesting, as we observed that it depends significantly on the size of the graph and impacts overall performance. A detailed examination of the effect of edge order and proposing more heuristics could further improve performance.

We provided a rough upper bound analysis of the execution time of \DPmst. Employing more sophisticated techniques to refine this analysis and achieve a tighter bound could lead to enhanced implementations. One potential approach is competitive analysis with an adversary model~\cite{Karp1992OnLineAV}. An online algorithm processes its input incrementally, much like \DPmst. Competitive analysis compares the performance of an online algorithm against an optimal offline algorithm that has full knowledge of the input sequence in advance. This method has proven effective in various domains, including online algorithms for paging~\cite{SleatorTarjan1985}, scheduling~\cite{Awebuch1992}, and distributed algorithms~\cite{Aspnes1998}. Applying these techniques to \DPmst\ could yield valuable insights and further optimization opportunities.