``The Future is Big Graphs" states the CACM paper~\cite{sakr2021futureIsBigGraphs} of the same title, where forty-one experts from the data management and large-scale-systems communities settled --after Dagstuhl Seminar 19491 held in Dec. 2019-- their conclusions about the opportunities and challenges of graph processing in the next decade. Beyond the corroboration that graph algorithms should be scalable to deal with the huge amount of data required by nowadays applications, this group of experts claims, among other issues, that, in order to succeed, graph algorithms have to deal with dynamic and streaming aspects of graph processing. This is, coping with updates such as edge insertions, changes, and deletions (dynamicity), as well as indefinitely growth and/or evolution as new data arrive (stream model). Additionally, one of the challenges these experts identified was to define a reference architecture for big graph processing.

Some representative examples are server networks, mobile phone networks, or sensor networks~\cite{Neely2005}, where the devices involved in the network are represented as nodes of a graph and the communications among devices are the weighted edges of the graph, since linking a pair of devices has an associated cost. The resulting resulting graph is fully dynamic as it captures the evolution of the networks along time: new devices can be added to the network, some others might be removed, and the links among them might be modified, involving therefore the insertion and deletion of edges of the graph.

Given an undirected and connected graph with weighted edges, a minimum weight spanning forest, minimum spanning forest, or simply minimum spanning tree (\mst); is a subset of the edges that connects all vertices and has minimum total weight among all such sets. The \mst\ problem is not only of theoretical interest, but also has a wide range of uses, including but not limited to clustering~\cite{AffinityClustering,KHAN20221113}, image segmentation~\cite{Wassenberg2009,LONG2020165308}, and the design of networks~\cite{Li2005}.

To comprehend and forecast the dynamics of evolving networks effectively, it is essential to maintain a minimum weight spanning forest of the dynamic graph. This ensures that the network can be adjusted and reconfigured as new connections are established or existing ones are disconnected. Moreover, in current applications, it is crucial to efficiently compute and maintain a large number of network updates involving potentially a huge number of devices that might be distributed in distant spatial locations~\cite{Tang2009,Tan2010}.

An example of dynamic graphs in which we need to maintain a minimum weight spanning forest can be found in the standard IEEE 802.1Q~\cite{IEEE8021Q}. This standard outlines the support of the Media Access Control (MAC) Service in Bridged Networks, the operational principles of such networks, and the functioning of MAC Bridges and VLAN Bridges, encompassing aspects like management, protocols, and algorithms. In order to provide simple and full connectivity throughout a bridged network comprising arbitrarily interconnected bridges, the Spanning Tree Protocol and some of its variants, such as Rapid Spanning Tree Protocol (RSTP) or the Multiple Spanning Tree Protocol (MSTP), are used in each bridge. The primary purpose of STP is to avoid bridge loops and the broadcast storms they cause. Additionally, Spanning Tree enables a network architecture to incorporate redundant links to ensure system reliability in case a primary link malfunctions.


This work focuses on applying the Dynamic Pipeline Approach (\dpm) \cite{Pasarella2024} to maintain a dynamic graph as well as its \mst\ providing a  parallel Kruskal's algorithm. The study includes the development, optimization, and analysis of the \DPmst\ algorithm. 
Several optimizations are explored from the implementation of the characterization to optimizations of the \dpm\ itself. The performance of \DPmst\ is compared with \FKruskal\ and a message-passing implementation of {\tt Prim}'s algorithm on various graph sizes and densities to assess scalability and efficiency.

%This work focuses on applying the Dynamic Pipeline Approach (\dpm) \cite{Pasarella2024} to parallelize Kruskal's algorithm for computing and maintaining the \mst\ in dynamic graphs using the \Go\ programming language. The study includes the development, optimization, and analysis of the \DPmst\ algorithm, leveraging \Goâ€™s concurrency features like goroutines and channels.

%Key optimizations explored are storing multiple roots per filter, disentangling message passing from MST maintenance, and caching the MST to avoid redundant computations. The performance of \DPmst\ is compared with \FKruskal\ and a message-passing implementation of {\tt Prim}'s algorithm on various graph sizes and densities to assess scalability and efficiency.

The study is limited to specific types of graphs, focusing on random static and real-world dynamic graphs. Experiments are conducted primarily on single-core and multi-core machines, not extending to distributed computing environments. While comparisons with \FKruskal\ and {\tt Prim}'s algorithm are included, not all existing \mst\ algorithms are covered since mostly are theoretical, little implementations are available and it some experimental results show that they do not behave properly in large graphs.

The research does not encompass all possible optimizations or address comprehensive memory management techniques beyond those relevant to \Go\ and \dpm. By defining these boundaries, the study aims to provide a focused investigation into the parallelization of Kruskal's algorithm using \dpm\ within the specified context.


This work comprises five chapters, with this introductory chapter laying the foundation. Chapter~\ref{chap:preliminaries} -Preliminaries- provides an overview of the state of the art, as well as relevant algorithms used throughout the research. Chapter~\ref{chap:dpmst} -\mst\ characterization in the \dpm- explains the main contribution of this project: how the DPA is utilized to solve the \mst problem.Chapter~\ref{chap:experiments} -Experimental Study- describes the experiments conducted, their motivation, the results, and the subsequent analysis. Finally, a conclusion is presented in Chapter~\ref{chap:conclusion}, summarizing the findings and suggesting future research directions.
